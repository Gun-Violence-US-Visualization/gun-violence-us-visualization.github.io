{"ast":null,"code":"// animateScroll.js\nconst pow = Math.pow; // The easing function that makes the scroll decelerate over time\n\nfunction easeOutQuart(x) {\n  return 1 - pow(1 - x, 4);\n}\n\nexport function animateScroll(_ref) {\n  let {\n    targetPosition,\n    initialPosition,\n    duration\n  } = _ref;\n  let start;\n  let position;\n  let animationFrame;\n  const requestAnimationFrame = window.requestAnimationFrame;\n  const cancelAnimationFrame = window.cancelAnimationFrame; // maximum amount of pixels we can scroll\n\n  const maxAvailableScroll = document.documentElement.scrollHeight - document.documentElement.clientHeight;\n  const amountOfPixelsToScroll = initialPosition - targetPosition;\n\n  function step(timestamp) {\n    if (start === undefined) {\n      start = timestamp;\n    }\n\n    const elapsed = timestamp - start; // this just gives us a number between 0 (start) and 1 (end)\n\n    const relativeProgress = elapsed / duration; // ease out that number\n\n    const easedProgress = easeOutQuart(relativeProgress); // calculate new position for every thick of the requesAnimationFrame\n\n    position = initialPosition - amountOfPixelsToScroll * Math.min(easedProgress, 1); // set the scrollbar position\n\n    window.scrollTo(0, position); // Stop when max scroll is reached\n\n    if (initialPosition !== maxAvailableScroll && window.scrollY === maxAvailableScroll) {\n      cancelAnimationFrame(animationFrame);\n      return;\n    } // repeat until the end is reached\n\n\n    if (elapsed < duration) {\n      animationFrame = requestAnimationFrame(step);\n    }\n  }\n\n  animationFrame = requestAnimationFrame(step);\n}","map":{"version":3,"sources":["/Users/lion/Sites/Visualization/project-on-github/Gun_Violence_US_Visualization/src/utils/animateScroll.js"],"names":["pow","Math","easeOutQuart","x","animateScroll","targetPosition","initialPosition","duration","start","position","animationFrame","requestAnimationFrame","window","cancelAnimationFrame","maxAvailableScroll","document","documentElement","scrollHeight","clientHeight","amountOfPixelsToScroll","step","timestamp","undefined","elapsed","relativeProgress","easedProgress","min","scrollTo","scrollY"],"mappings":"AAAA;AAEA,MAAMA,GAAG,GAAGC,IAAI,CAACD,GAAjB,C,CAEA;;AACA,SAASE,YAAT,CAAsBC,CAAtB,EAAyB;AACvB,SAAO,IAAIH,GAAG,CAAC,IAAIG,CAAL,EAAQ,CAAR,CAAd;AACD;;AAED,OAAO,SAASC,aAAT,OAAsE;AAAA,MAA/C;AAAEC,IAAAA,cAAF;AAAkBC,IAAAA,eAAlB;AAAmCC,IAAAA;AAAnC,GAA+C;AAC3E,MAAIC,KAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,cAAJ;AAEA,QAAMC,qBAAqB,GAAGC,MAAM,CAACD,qBAArC;AACA,QAAME,oBAAoB,GAAGD,MAAM,CAACC,oBAApC,CAN2E,CAQ3E;;AACA,QAAMC,kBAAkB,GACtBC,QAAQ,CAACC,eAAT,CAAyBC,YAAzB,GACAF,QAAQ,CAACC,eAAT,CAAyBE,YAF3B;AAIA,QAAMC,sBAAsB,GAAGb,eAAe,GAAGD,cAAjD;;AAEA,WAASe,IAAT,CAAcC,SAAd,EAAyB;AACvB,QAAIb,KAAK,KAAKc,SAAd,EAAyB;AACvBd,MAAAA,KAAK,GAAGa,SAAR;AACD;;AAED,UAAME,OAAO,GAAGF,SAAS,GAAGb,KAA5B,CALuB,CAOvB;;AACA,UAAMgB,gBAAgB,GAAGD,OAAO,GAAGhB,QAAnC,CARuB,CAUvB;;AACA,UAAMkB,aAAa,GAAGvB,YAAY,CAACsB,gBAAD,CAAlC,CAXuB,CAavB;;AACAf,IAAAA,QAAQ,GACNH,eAAe,GAAGa,sBAAsB,GAAGlB,IAAI,CAACyB,GAAL,CAASD,aAAT,EAAwB,CAAxB,CAD7C,CAduB,CAiBvB;;AACAb,IAAAA,MAAM,CAACe,QAAP,CAAgB,CAAhB,EAAmBlB,QAAnB,EAlBuB,CAoBvB;;AACA,QACEH,eAAe,KAAKQ,kBAApB,IACAF,MAAM,CAACgB,OAAP,KAAmBd,kBAFrB,EAGE;AACAD,MAAAA,oBAAoB,CAACH,cAAD,CAApB;AACA;AACD,KA3BsB,CA6BvB;;;AACA,QAAIa,OAAO,GAAGhB,QAAd,EAAwB;AACtBG,MAAAA,cAAc,GAAGC,qBAAqB,CAACS,IAAD,CAAtC;AACD;AACF;;AAEDV,EAAAA,cAAc,GAAGC,qBAAqB,CAACS,IAAD,CAAtC;AACD","sourcesContent":["// animateScroll.js\n\nconst pow = Math.pow;\n\n// The easing function that makes the scroll decelerate over time\nfunction easeOutQuart(x) {\n  return 1 - pow(1 - x, 4);\n}\n\nexport function animateScroll({ targetPosition, initialPosition, duration }) {\n  let start;\n  let position;\n  let animationFrame;\n\n  const requestAnimationFrame = window.requestAnimationFrame;\n  const cancelAnimationFrame = window.cancelAnimationFrame;\n\n  // maximum amount of pixels we can scroll\n  const maxAvailableScroll =\n    document.documentElement.scrollHeight -\n    document.documentElement.clientHeight;\n\n  const amountOfPixelsToScroll = initialPosition - targetPosition;\n\n  function step(timestamp) {\n    if (start === undefined) {\n      start = timestamp;\n    }\n\n    const elapsed = timestamp - start;\n\n    // this just gives us a number between 0 (start) and 1 (end)\n    const relativeProgress = elapsed / duration;\n\n    // ease out that number\n    const easedProgress = easeOutQuart(relativeProgress);\n\n    // calculate new position for every thick of the requesAnimationFrame\n    position =\n      initialPosition - amountOfPixelsToScroll * Math.min(easedProgress, 1);\n\n    // set the scrollbar position\n    window.scrollTo(0, position);\n\n    // Stop when max scroll is reached\n    if (\n      initialPosition !== maxAvailableScroll &&\n      window.scrollY === maxAvailableScroll\n    ) {\n      cancelAnimationFrame(animationFrame);\n      return;\n    }\n\n    // repeat until the end is reached\n    if (elapsed < duration) {\n      animationFrame = requestAnimationFrame(step);\n    }\n  }\n\n  animationFrame = requestAnimationFrame(step);\n}\n"]},"metadata":{},"sourceType":"module"}